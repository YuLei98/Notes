题目背景
<<<<<<< HEAD
顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用邻域均值来判断一个像素是否处于较暗区域，然后仅对处于较暗区域的像素进行降噪处理。

题目描述
待处理的灰度图像长宽皆为 n 个像素，可以表示为一个 n×n 大小的矩阵 A，其中每个元素是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。 对于矩阵中任意一个元素 Aij（0≤i,j<n），其邻域定义为附近若干元素的集和：
=======
顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用邻域
均值来判断一个像素是否处于较暗区域，然后仅对处于较暗区域的像素进行降噪处理。

题目描述
待处理的灰度图像长宽皆为 n 个像素，可以表示为一个 n×n 大小的矩阵 A，其中每个元素是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。 对于矩阵中任意一个元素 Aij（0≤i,j<n），其邻域定
义为附近若干元素的集和：
>>>>>>> master

Neighbor(i,j,r)={Axy|0≤x,y<n and |x−i|≤r and |y−j|≤r}
这里使用了一个额外的参数 r 来指明 Aij 附近元素的具体范围。根据定义，易知 Neighbor(i,j,r) 最多有 (2r+1)2 个元素。

<<<<<<< HEAD
如果元素 Aij 邻域中所有元素的平均值小于或等于一个给定的阈值 t，我们就认为该元素对应位置的像素处于较暗区域。 下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示为白色。

=======
如果元素 Aij 邻域中所有元素的平均值小于或等于一个给定的阈值 t，我们就认为该元素对应位置的像素处于较暗区域。 下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示
为白色。
>>>>>>> master
现给定邻域参数 r 和阈值 t，试统计输入灰度图像中有多少像素处于较暗区域。

输入格式
从标准输入读入数据。

输入共 n+1 行。
<<<<<<< HEAD

输入的第一行包含四个用空格分隔的正整数 n、L、r 和 t，含义如前文所述。

=======
输入的第一行包含四个用空格分隔的正整数 n、L、r 和 t，含义如前文所述。
>>>>>>> master
第二到第 n+1 行输入矩阵 A。 第 i+2（0≤i<n）行包含用空格分隔的 n 个整数，依次为 Ai0,Ai1,⋯,Ai(n−1)。

输出格式
输出到标准输出。

输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。

<<<<<<< HEAD
样例1输入
=======
样例1:
输入
>>>>>>> master
4 16 1 6
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
<<<<<<< HEAD
样例1输出
7
样例2输入
=======
输出
7

样例2
输入
>>>>>>> master
11 8 2 2
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 7 0 0 7 7 0
7 0 7 0 7 0 7 0 7 0 7
7 0 0 0 7 0 0 0 7 0 7
7 0 0 0 0 7 0 0 7 7 0
7 0 0 0 0 0 7 0 7 0 0
7 0 7 0 7 0 7 0 7 0 0
0 7 0 0 0 7 0 0 7 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
<<<<<<< HEAD
样例2输出
83
=======
输出
83

>>>>>>> master
子任务
70 的测试数据满足 n≤100、r≤10。

全部的测试数据满足 0<n≤600、0<r≤100 且 2≤t<L≤256。
<<<<<<< HEAD
————————————————————————————————————————————————————————————————————————————————
=======
————————————————————————————————————————————————————————————————————————————————————————————————————————————————
>>>>>>> master

思路：二维前缀和求各点领域内的像素和。




void ac(){
    int n, r, t, L;
    cin >> n >> L >> r >> t;
    VVI v(n, VI(n));
    FOR(i, 0, n) FOR (j, 0, n) cin >> v[i][j];

    VVI pre(n + 1, VI(n + 1));
    FFOR(i, 1, n) FFOR(j, 1, n) pre[i][j] = pre[i][j - 1] + pre[i - 1][j] + v[i - 1][j - 1] - pre[i - 1][j - 1];
    
    int cnt = 0;
    int a, b, c, d;
    FFOR (i, 1, n){
        FFOR (j, 1, n){
            a = i - r - 1 >= 1 ? i - r - 1 : 0;
            b = j - r - 1 >= 1 ? j - r - 1 : 0;
            c = i + r <= n ? i + r : n;
            d = j + r <= n ? j + r : n;
            cnt += pre[c][d] - pre[a][d] - pre[c][b] + pre[a][b] <= t * (c - a) * (d - b);
        }
    }
    cout << cnt << endl;
<<<<<<< HEAD
}
=======
}
>>>>>>> master
