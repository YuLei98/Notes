一、0-1背包
  有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

  第 i 件物品的体积是 vi，价值是 wi。
  
  求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
  
  Solution : 
  '''

      //1d
      vector<int> W(N), V(N);
      for(int i = 0; i < N; i++){
          cin >> W[i] >> V[i];
      }
      vector<int> f(M + 1);
      for(int i = 0; i < N; i++){
          for(int j = M; j >= W[i]; j--){           //从后往前
          //for(int j = W[i]; j <= M; ++j){        //从前往后，完全背包
              f[j] = max(f[j], f[j - W[i]] + V[i]); 
              cout << f[j] << " ";
          }
          cout << endl;
      }
      cout << f[M];
    
    
      //2d
      /*vector<int> W(N + 1), V(N + 1);
      for(int i = 1; i <= N; i++){
          cin >> W[i] >> V[i];
      }
      vector<vector<int>> dp(N + 1, vector<int>(M + 1));
      for(int i = 1; i <= N; i++){
          //for(int j = 1; j <= M; j++){      //从前往后从后往前都可以
          for(int j = M; j >= 0; --j){
              if (j < W[i]) dp[i][j] = dp[i - 1][j];
              else dp[i][j] = max(dp[i - 1][j - W[i]] + V[i], dp[i - 1][j]);
          }
      }
      cout << dp[N][M];*/
      
    '''
二、完全背包
  有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
  第 i 种物品的体积是 vi，价值是 wi。
  求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
  输出最大价值。

  输入格式
  第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

  接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

  输出格式
  输出一个整数，表示最大价值。

  数据范围
  0<N,V≤1000
  0<vi,wi≤1000
  
  Solution :
      //1d
      vector<int> f(M + 1);
      for (int i = 1; i <= N; ++i){
          //for (int j = 0; j <= M; ++j){
              //if (j >= W[i])
          for (int j = W[i]; j <= M; ++j){
                  f[j] = max(f[j], f[j - W[i]] + V[i]);
          }
      }
      cout << f[M];
      
      
      //2d
      /*vector<vector<int>> dp(N + 1, vector<int>(M + 1));
      for(int i = 1; i <= N; i++){
          //for(int j = W[i]; j <= M; j++){       //不能从W[i]开始   反例：20 200     //为什么？
                                                                           24 50
                                                                           42 60
                                                                           20 49
                                                                           7 15
                                                                           48 115
                                                                           4 11
                                                                           3 8
                                                                           7 5
                                                                           52 66
                                                                           50 25
                                                                           5 8
                                                                           9 25
                                                                           14 40
                                                                           9 22
                                                                           55 42
                                                                           40 30
                                                                           35 49
                                                                           33 16
                                                                           12 12
                                                                           65 127     //输出570，答案571
          //for(int j = M; j >= 0; --j){         //不能从后往前
          for (int j = 0; j <= M; ++j){
              if (j < W[i]) dp[i][j] = dp[i - 1][j];
              else 
                  //dp[i][j] = max(dp[i - 1][j - W[i]] + V[i], dp[i - 1][j]);     //01背包     注意i的区别
                  dp[i][j] = max(dp[i][j - W[i]] + V[i], dp[i - 1][j]);         //完全背包
          }
      }
      cout << dp[N][M];*/

三、多重背包
    有 N 种物品和一个容量是 V 的背包。

    第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

    求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
    输出最大价值。

    输入格式
    第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

    接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

    输出格式
    输出一个整数，表示最大价值。
    
    数据范围
    0<N,V≤100
    0<vi,wi,si≤100
    
    //思路：将每种背包分解成二进制组合，让这些二进制可以组合成任意数量的背包，如13 = 001 + 010 + 100 + 6, 题目就转化成了0-1背包

    '''
    #include <iostream>
    #include <vector>
    using namespace std;
    int main(){
    int NN, M;
        cin >> NN >> M;
        int v, w, s;
        vector<int> W(1), V(1);
        W.reserve(1000);V.reserve(1000);
        for (int i = 0; i < NN; ++i){
            cin >> v >> w >> s;
            for (int j = 0; j < 7; ++j){
                if (s <= 1 << j){
                    W.push_back(w * s);
                    V.push_back(v * s);
                    break;
                }else{
                    W.push_back(w * (1 << j));
                    V.push_back(v * (1 << j));
                    s -= 1 << j;
                    //if (!s) break;          //上一个if-else用<=，这里可以不用
                }
            }
        }
        int N = W.size();
    
        vector<vector<int>> dp(N , vector<int>(M + 1));             //数据量大用1D数组
        for (int i = 1; i < N; i++){
            for (int j = 0; j <= M; j++){
                if (j < W[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - W[i]] + V[i]);
                cout << dp[i][j] << " ";
            }
            cout << endl;
        }
        cout << dp[N - 1][M];
        return 0;
    }
    '''
    
    数据量特别大，用单调队列优化
