class UF{
    vector<int> f;   //father
public:
    int num;      //连通分量的数目
    /*如果从0开始，f[0]未使用，num会比目标值多一*/
    UF(int _n): f(_n), num(_n){
        iota(f.begin(), f.end(), 0);    //从start开始
    }
    int find(int x){
        if (x == f[x]) return x;
        else{
            f[x] = find(f[x]);           //路径压缩
            return f[x];
        }
    }
    bool merge(int x, int y){
        int fx = find(x), fy = find(y);
        if (fx != fy){
            f[fx] = fy;
            num --;
            return true;
        }
        return false;
    }
};



class UF{
    vector<int> fa, rank;
public:
    UF(int n): fa(n), rank(n) {
        iota(fa.begin(), fa.end(), 0);
        fill(rank.begin(), rank.end(), 1);
    }
    int find(int i){
        return i == fa[i] ? i : fa[i] = find(fa[i]);
    }
    void merge(int i, int j){
        int x = find(i), y = find(j);
        if (rank(x) <= rank(y)){
            fa[x] = y;
        }else{
            fa[y] = x;
        }
        if (rank[x] == rank[y] && x != y){
            rank[y]++;
        }
    }
};